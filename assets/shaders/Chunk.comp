#version 460 core
#define BLOCK_SIZE 16

out vec3 fragPos;

out vec2 v_TexCoords;
out float TextureIndex;

uniform mat4 projection;
uniform mat4 view;
uniform vec3 Position;

const int CHUNK_SIZE_X = 16;
const int CHUNK_SIZE_Y = 255;
const int CHUNK_SIZE_Z = 16;

// Positions locales des sommets d’un cube

const vec2 texCoords[6] = vec2[](
vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0),
vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0)
);

struct BlockFace {
    float positionX;
    float positionY;
    float positionZ;

    float minAABBX;
    float minAABBY;
    float minAABBZ;

    float maxAABBX;
    float maxAABBY;
    float maxAABBZ;

    float id;
    float FaceID;
};

layout(std430, binding = 0) buffer BlockData {
    BlockFace faces[];
};

void main() {

    int faceIndex = int(gl_VertexID/6);

    vec3 FaceVertices[6];

    vec3 mn = vec3(faces[faceIndex].minAABBX/BLOCK_SIZE,
    faces[faceIndex].minAABBY/BLOCK_SIZE,
    faces[faceIndex].minAABBZ/BLOCK_SIZE);

    vec3 mx = vec3(faces[faceIndex].maxAABBX/BLOCK_SIZE,
    faces[faceIndex].maxAABBY/BLOCK_SIZE,
    faces[faceIndex].maxAABBZ/BLOCK_SIZE);

    switch(int(faces[faceIndex].FaceID)) {
        // FRONT
        case 0:
            FaceVertices = vec3[](
            vec3(mn.x, mn.y, mx.z), vec3(mx.x, mn.y, mx.z), vec3(mx.x, mx.y, mx.z),
            vec3(mn.x, mn.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mn.x, mx.y, mx.z)
            );
            break;
        // BACK
        case 1:
            FaceVertices = vec3[](
            vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z),
            vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z)
            );
            break;
        // RIGHT
        case 2:
            FaceVertices = vec3[](
            vec3(mn.x, mn.y, mn.z), vec3(mn.x, mn.y, mx.z), vec3(mn.x, mx.y, mx.z),
            vec3(mn.x, mn.y, mn.z), vec3(mn.x, mx.y, mx.z), vec3(mn.x, mx.y, mn.z)
            );
            break;
        // LEFT
        case 3:
            FaceVertices = vec3[](
            vec3(mx.x, mn.y, mx.z), vec3(mx.x, mn.y, mn.z), vec3(mx.x, mx.y, mn.z),
            vec3(mx.x, mn.y, mx.z), vec3(mx.x, mx.y, mn.z), vec3(mx.x, mx.y, mx.z)
            );
            break;
        // TOP
        case 4:
            FaceVertices = vec3[](
            vec3(mn.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mn.z),
            vec3(mn.x, mx.y, mx.z), vec3(mx.x, mx.y, mn.z), vec3(mn.x, mx.y, mn.z)
            );
            break;
        // BOTTOM
        case 5:
            FaceVertices = vec3[](
            vec3(mn.x, mn.y, mn.z), vec3(mx.x, mn.y, mn.z), vec3(mx.x, mn.y, mx.z),
            vec3(mn.x, mn.y, mn.z), vec3(mx.x, mn.y, mx.z), vec3(mn.x, mn.y, mx.z)
            );
            break;
    }
    int vertexIndex = gl_VertexID % 6;

    vec3 localPosition = vec3(faces[faceIndex].positionX, faces[faceIndex].positionY, faces[faceIndex].positionZ);
    fragPos = FaceVertices[vertexIndex] + localPosition;

    // Assigner les coordonnées de texture (UV)
    v_TexCoords = texCoords[vertexIndex % 6];
    TextureIndex = faces[faceIndex].id;

    gl_Position = projection * view * vec4(fragPos+Position, 1.0);
}

