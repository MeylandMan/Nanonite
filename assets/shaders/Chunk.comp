#version 460 core
#define BLOCK_SIZE 16

out vec3 fragPos;

out vec2 v_TexCoords;
out float TextureIndex;

// Positions locales des sommets d’un cube

const vec2 texCoords[6] = vec2[](
vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0),
vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0)
);

struct BlockFace {
    float positionX, positionY, positionZ;
    float minAABBX, minAABBY, minAABBZ;
    float maxAABBX, maxAABBY, maxAABBZ;

    float id;
    float FaceID;
};

struct Plane {
    float a, b, c, d;
};


layout(std430, binding = 0) buffer BlockData {
    BlockFace faces[];
};

uniform mat4 projection;
uniform mat4 view;
uniform vec3 Position;

#define PROJECTION_VIEW_MATRIX projection * view

vec3[6] getVertices(uint faceID, vec3 mn, vec3 mx);

void setPlane(Plane place, float a, float b, float c, float d);
void normalizePlane(Plane plane);
bool isPointInside(Plane plane, float x, float y, float z);
Plane[6] getViewFrustum();

void main() {

    int faceIndex = int(gl_VertexID/6);

    vec3 mn = vec3(faces[faceIndex].minAABBX/BLOCK_SIZE,
    faces[faceIndex].minAABBY/BLOCK_SIZE,
    faces[faceIndex].minAABBZ/BLOCK_SIZE);

    vec3 mx = vec3(faces[faceIndex].maxAABBX/BLOCK_SIZE,
    faces[faceIndex].maxAABBY/BLOCK_SIZE,
    faces[faceIndex].maxAABBZ/BLOCK_SIZE);

    vec3 FaceVertices[6] = getVertices(uint(faces[faceIndex].FaceID), mn, mx);

    int vertexIndex = gl_VertexID % 6;

    vec3 localPosition = vec3(faces[faceIndex].positionX, faces[faceIndex].positionY, faces[faceIndex].positionZ);
    fragPos = FaceVertices[vertexIndex] + localPosition;

    // Assigner les coordonnées de texture (UV)
    v_TexCoords = texCoords[vertexIndex % 6];
    TextureIndex = faces[faceIndex].id;

    Plane viewFrustum[6] = getViewFrustum();

    vec4 worldPosition = PROJECTION_VIEW_MATRIX * vec4(fragPos+Position, 1.0);
    bool isInside;
    for(uint i = 0; i < 6; i++) {
        isInside = isPointInside(viewFrustum[i], worldPosition.x, worldPosition.y, worldPosition.z);
    }

    if (!isInside)
        worldPosition = vec4(-200000000000.0, -2000000000000.0, -20000000000.0, 1.0);

    gl_Position = worldPosition;
}

vec3[6] getVertices(uint faceID, vec3 mn, vec3 mx) {
    vec3 vertices[6];
    switch(faceID) {
        // FRONT
        case 0:
            vertices = vec3[](
            vec3(mn.x, mn.y, mx.z), vec3(mx.x, mn.y, mx.z), vec3(mx.x, mx.y, mx.z),
            vec3(mn.x, mn.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mn.x, mx.y, mx.z)
            );
            break;
        // BACK
        case 1:
            vertices = vec3[](
            vec3(mx.x, mn.y, mn.z), vec3(mn.x, mn.y, mn.z), vec3(mn.x, mx.y, mn.z),
            vec3(mx.x, mn.y, mn.z), vec3(mn.x, mx.y, mn.z), vec3(mx.x, mx.y, mn.z)
            );
            break;
        // RIGHT
        case 2:
            vertices = vec3[](
            vec3(mn.x, mn.y, mn.z), vec3(mn.x, mn.y, mx.z), vec3(mn.x, mx.y, mx.z),
            vec3(mn.x, mn.y, mn.z), vec3(mn.x, mx.y, mx.z), vec3(mn.x, mx.y, mn.z)
            );
            break;
        // LEFT
        case 3:
            vertices = vec3[](
            vec3(mx.x, mn.y, mx.z), vec3(mx.x, mn.y, mn.z), vec3(mx.x, mx.y, mn.z),
            vec3(mx.x, mn.y, mx.z), vec3(mx.x, mx.y, mn.z), vec3(mx.x, mx.y, mx.z)
            );
            break;
        // TOP
        case 4:
            vertices = vec3[](
            vec3(mn.x, mx.y, mx.z), vec3(mx.x, mx.y, mx.z), vec3(mx.x, mx.y, mn.z),
            vec3(mn.x, mx.y, mx.z), vec3(mx.x, mx.y, mn.z), vec3(mn.x, mx.y, mn.z)
            );
            break;
        // BOTTOM
        case 5:
            vertices = vec3[](
            vec3(mn.x, mn.y, mn.z), vec3(mx.x, mn.y, mn.z), vec3(mx.x, mn.y, mx.z),
            vec3(mn.x, mn.y, mn.z), vec3(mx.x, mn.y, mx.z), vec3(mn.x, mn.y, mx.z)
            );
            break;
    }

    return vertices;
}

void setPlane(Plane plane, float a, float b, float c, float d) {
    plane.a = a;
    plane.b = b;
    plane.c = c;
    plane.d = d;
}

void normalizePlane(Plane plane) {
    float l = sqrt(plane.a * plane.a + plane.b * plane.b + plane.c * plane.c);
    plane.a /= l;
    plane.b /= l;
    plane.c /= l;
    plane.d /= l;
}

bool isPointInside(Plane plane, float x, float y, float z) {
    return plane.a * x + plane.b * y + plane.c * z + plane.d >= 0;
}

Plane[6] getViewFrustum() {
    mat4 vpMatrix = PROJECTION_VIEW_MATRIX;

    Plane planes[6];

    // Récupération des 6 plans
    setPlane(planes[0], vpMatrix[0][3] + vpMatrix[0][0], vpMatrix[1][3] + vpMatrix[1][0], vpMatrix[2][3] + vpMatrix[2][0], vpMatrix[3][3] + vpMatrix[3][0]); // Plan gauche
    setPlane(planes[1], vpMatrix[0][3] - vpMatrix[0][0], vpMatrix[1][3] - vpMatrix[1][0], vpMatrix[2][3] - vpMatrix[2][0], vpMatrix[3][3] - vpMatrix[3][0]); // Plan droit
    setPlane(planes[2], vpMatrix[0][3] + vpMatrix[0][1], vpMatrix[1][3] + vpMatrix[1][1], vpMatrix[2][3] + vpMatrix[2][1], vpMatrix[3][3] + vpMatrix[3][1]); // Plan bas
    setPlane(planes[3], vpMatrix[0][3] - vpMatrix[0][1], vpMatrix[1][3] - vpMatrix[1][1], vpMatrix[2][3] - vpMatrix[2][1], vpMatrix[3][3] - vpMatrix[3][1]); // Plan haut
    setPlane(planes[3], vpMatrix[0][3] + vpMatrix[0][2], vpMatrix[1][3] + vpMatrix[1][2], vpMatrix[2][3] + vpMatrix[2][2], vpMatrix[3][3] + vpMatrix[3][2]); // Plan proche
    setPlane(planes[3], vpMatrix[0][3] - vpMatrix[0][2], vpMatrix[1][3] - vpMatrix[1][2], vpMatrix[2][3] - vpMatrix[2][2], vpMatrix[3][3] - vpMatrix[3][2]); // Plan Eloigné

    for(uint i = 0; i < 6; i++) {
        normalizePlane(planes[i]);
    }

    return planes;
}